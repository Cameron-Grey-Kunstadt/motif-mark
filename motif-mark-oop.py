import argparse
import re, os
import bioinfo
import cairo
import random
# Cameron Kunstadt
# UO BGMP
# 2/27/2025

#TODO: 
# - deal with the weird ys in the unique motifs list
# - basically scale nt to pixels
# - allow for the printout of multiple record graphs
# - add labels and key
# - find better ways to add color

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--fasta",)  
parser.add_argument('-m', "--motif")
args = parser.parse_args()


class FastaRecord:
    '''A FastaRecord object serves to parse and hold useful information from a FASTA header
    and a FASTA sequence, and to find motifs within the sequence, based on the given unique_motif_list.
    Motifs are create as Motif objects, and saved in a list.'''
    def __init__(self, header, seq, unique_motif_list):
        self.header = header
        self.seq = seq
        self.length = len(seq)
        self.gene = self.parse_gene(header)
        self.needs_revcomp = self.parse_needs_revcomp(header)

        if self.needs_revcomp == True:
            self.seq = bioinfo.reverse_compliment(seq)

        self.unique_motif_list = unique_motif_list
        self.motif_object_list = self.find_motifs(self.seq, self.unique_motif_list)
        self.exon_start, self.exon_stop = self.get_exon_range(seq)

    
    def parse_gene(self, header):
        '''Pulls gene out of fasta header, assumes its the first letters & numbers
        until the first space'''
        gene_match = re.search(">[A-Z0-9]+", header)
        gene = gene_match.group()
        return gene[1:]
    
    def parse_needs_revcomp(self, header):
        '''Determines if the seq needs a reverse complement generated by
        scraping the header line for "reverse complement"'''
        rev_comp = re.search("reverse complement", header)
        
        try:
            if rev_comp.group():
                return True
        except AttributeError:
            return False
        
    def get_exon_range(self, seq):
        '''Gets the exon from the given sequence provided it has one, determines
        this by getting the first and last capital letter in the sequence'''
        capital_letters = list(re.finditer(r'[A-Z]', seq))
        exon_start = capital_letters[0].start()
        exon_stop = capital_letters[-1].start()

        return exon_start, exon_stop
    
    def find_motifs(self, seq, unique_motif_list):
        '''Searches for all the instances of motifs in the given sequence
        and creates motif objects for each of them'''
        motif_objects_list = []

        for unique_motif in unique_motif_list:
            motif_instances = list(re.finditer(unique_motif, seq))
            for motif_instance in motif_instances:
                motif_span = motif_instance.span()
                motif_start = motif_span[0]
                motif_stop = motif_span[1]

                motif_object = Motif(unique_motif, unique_motif_color_dict[unique_motif], len(seq), motif_start, motif_stop)
                motif_objects_list.append(motif_object)

        return motif_objects_list


class Motif:
    '''A Motif object holds important information about the motifs found in a given
    FASTA record, and allows for easy drawing on a pycairo context.'''
    def __init__(self, motif, color, seq_length, motif_start, motif_stop):
        self.motif = motif
        self.color = color
        self.seq_length = seq_length
        self.motif_start = motif_start
        self.motif_stop = motif_stop

    def draw_line(self, x, y):
        r, g, b = self.color

        ctx.set_source_rgb(r/255, g/255, b/255)
        ctx.rectangle(x, y, 5, 50)
        ctx.fill()
        ctx.stroke()

# I will probably delete this, this isn't my favorite
def random_color_generator():
    r = random.randint(0, 255)
    g = random.randint(0, 0)
    b = random.randint(0, 255)
    return (r, g, b)

def convert_bp_to_pixels(basepairs):
    return None



# Set surface, paint white
surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 700, 350)
ctx = cairo.Context(surface)
ctx.set_source_rgb(255, 255, 255)
ctx.paint()

# Set main line as black, stroke
ctx.set_source_rgb(0, 0, 0)
ctx.move_to(25,175)
ctx.line_to(675, 175)
ctx.set_line_width(10)

ctx.stroke()

# Set Exon, fill, stroke
ctx.set_source_rgb(0.4, 0.9, 0.4)
ctx.rectangle(200, 150, 300, 50)

ctx.fill()
ctx.stroke()


# Create unique list of motifs, assign each a unique random color and put into dictionary
unique_motif_list = []
unique_motif_color_dict = {}

with open(args.motif, 'r') as motif_file:
    for line in motif_file: unique_motif_list.append(line.strip())

for unique_motif in unique_motif_list: unique_motif_color_dict[unique_motif] = random_color_generator()


# Not assuming the incoming file is oneline, so a temp one-line fasta file is created
bioinfo.oneline_fasta(args.fasta, "temp_oneline.fasta")


with open("temp_oneline.fasta", 'r') as fasta:
    while True:
        header = fasta.readline()
        if header == "":
            break
        seq = fasta.readline()

        record = FastaRecord(header, seq, unique_motif_list)
        for motif in record.motif_object_list:
            motif.draw_line(motif.motif_start,150)


os.remove('temp_oneline.fasta')
surface.write_to_png('test_rect_and_line.png')